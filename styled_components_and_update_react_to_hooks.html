<!DOCTYPE html><html lang="zh-cn"><head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="mebtte">
<meta name="keywords" content="HTML,CSS,JavaScript,Web">

<!-- open graph -->
<meta property="og:type" content="website">
<meta property="og:image" content="/article/6ed5faa0573b2a5a9d47232c9a71fb88.png">

<link rel="shortcut icon" type="image/png" href="/article/6ed5faa0573b2a5a9d47232c9a71fb88.png">
<link rel="sitemap" type="application/xml" href="/article/sitemap.xml">

<link rel="preload" href="/article/dc2debd6c1aa714de8960f48d6f6f1d1.ttf" as="font" crossorigin="anonymous">
<link rel="preload" href="/article/7ceed3c126da541a7aaee7d53bc1b5b7.ttf" as="font" crossorigin="anonymous">

  <style>
  @font-face {
    font-family: common_font;
    src: url(/article/7ceed3c126da541a7aaee7d53bc1b5b7.ttf);
  }

  html, body {
    margin: 0;
    padding: 0;
  }

  body {
    --primary-color: rgb(237, 106, 94);

    --normal-color: #333;
    --secondary-color: #888;
    --tertiary-color: #ddd;
    --backgroud: rgb(244, 244, 244);

    --border-radius: 2px;
    --transition-duration: 0.3s;

    background-color: var(--backgroud);
    transition: background-color var(--transition-duration);
  }

  body.dark-theme {
    --normal-color: #eee;
    --secondary-color: #888;
    --tertiary-color: #444;
    --backgroud: #333;
  }
</style>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const darkTheme = window.localStorage.getItem('dark_theme');
    if (darkTheme) {
      document.body.classList.remove('light-theme');
      document.body.classList.add('dark-theme');
    }
  })
</script>


  <title>styled-components 与 React Hooks 升级指北 - Answer</title>

  <link rel="preload" href="/article/ae8c73e1befc96875cb701f0ecb43e22.ttf" as="font" crossorigin="anonymous">
  <style>
    @font-face {
      font-family: article_font_styled_components_and_update_react_to_hooks;
      src: url(/article/ae8c73e1befc96875cb701f0ecb43e22.ttf);
    }
    article {
      font-family: article_font_styled_components_and_update_react_to_hooks;
    }
  </style>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/firacode@5.2.0/distr/fira_code.min.css">
  <link rel="stylesheet" href="/article/ece570de77ba673c17121d06fc929bd9.css">
</head>

<body class="light-theme">
  <style>
  @font-face {
    font-family: title_font;
    src: url(/article/dc2debd6c1aa714de8960f48d6f6f1d1.ttf);
  }

  .page-header {
    max-width: 840px;
    margin: 40px auto;
    padding: 0 30px;
    display: flex;
    align-items: center;
  }

  .page-header_title {
    flex: 1;
    min-width: 0;
    font-size: 64px;
    font-family: title_font;
    margin: 0;
  }

  h1.page-header_title  {
    color: var(--normal-color);
  }

  h2.page-header_title {
    color: var(--primary-color);
  }

  .page-header_title > a {
    color: inherit;
    text-decoration: none;
  }

  .theme-changer {
    background-color: transparent;
    padding: 0;
    margin: 0;
    outline: none;
    border: none;
  }

  .page-header_icon {
    display: block;
    margin-left: 16px;
    user-select: none;
    width: 20px;
    height: 20px;
    cursor: pointer;
  }

  .dark-theme .page-header_icon__light-theme {
    display: none;
  }

  .light-theme .page-header_icon__dark-theme {
    display: none;
  }
</style>

<header class="page-header">
  
    <h2 class="page-header_title">
      <a href="/article/">Answer</a>
    </h2>
  
  <button class="theme-changer" type="button">
    <img class="page-header_icon page-header_icon__dark-theme" src="/article/c81f837b51ca388c1a54c51c5d0c6b15.png" alt="light theme">
    <img class="page-header_icon page-header_icon__light-theme" src="/article/802654de2a9a0f0d2667e6aed83d682f.png" alt="dark theme">
  </button>
  <a href="/article/rss.xml">
    <img class="page-header_icon page-header_icon__dark-theme" src="/article/6594d1f64750503bee10571143bd5019.png" alt="rss">
    <img class="page-header_icon page-header_icon__light-theme" src="/article/e31ad23031e5bcb34e8d4a424ba0c100.png" alt="rss">
  </a>
  <a href="https://github.com/mebtte/article">
    <img class="page-header_icon page-header_icon__dark-theme" src="/article/8a0ad2aed00666d6d2366358a4e6e9ad.png" alt="github">
    <img class="page-header_icon page-header_icon__light-theme" src="/article/184c800e11079b13904f308161071b62.png" alt="github">
  </a>
</header>

<script>
  (() => {
    const themeChanger = document.querySelector('.theme-changer');
    themeChanger.addEventListener('click', () => {
      if (document.body.classList.contains('dark-theme')) {
        document.body.classList.remove('dark-theme');
        document.body.classList.add('light-theme');
        window.localStorage.removeItem('dark_theme');
      } else {
        document.body.classList.remove('light-theme');
        document.body.classList.add('dark-theme');
        window.localStorage.setItem('dark_theme', '1');
      }
    });
  })()
</script>

  <article>
    <style>
.article-header {
  max-width: 840px;
  margin: 40px auto;
  padding: 0 30px;
}

.article-title {
  color: var(--normal-color);
  font-size: 32px;
  margin: 0;
  padding: 0;
  line-height: 1.5;
}

.article-title a {
  text-decoration: none;
  color: inherit;
}

.article-create-time {
  color: var(--secondary-color);
  font-size: 14px;
  font-family: common_font;
}
</style>

<section class="article-header">
  <h1 class="article-title">
    <a href="/article/styled_components_and_update_react_to_hooks">styled-components 与 React Hooks 升级指北</a>
  </h1>
  <time class="article-create-time">2020-03-28</time>
</section>

    <style>
  code {
    font-family: 'Fira Code' !important;
  }

  article a {
    color: var(--normal-color);
    text-decoration-color: var(--primary-color);
  }

  article h2, article h3, article h4, article h5, article h6 {
    max-width: 840px;
    padding: 0 30px;
    margin: 0 auto;
    line-height: 1.5;
    color: var(--normal-color);
  }

  article h2 {
    margin-top: 28px;
    font-size: 28px;
  }

  article h3 {
    margin-top: 26px;
    font-size: 25px;
  }

  article h4 {
    margin-top: 24px;
    font-size: 22px;
  }

  article h5 {
    margin-top: 22px;
    font-size: 19px;
  }

  article h6 {
    margin-top: 20px;
    font-size: 16px;
  }

  article p {
    max-width: 840px;
    padding: 0 30px;
    font-size: 16px;
    margin: 15px auto;
    line-height: 1.8;
    color: var(--normal-color);
  }

  article p code {
    padding: 0 4px;
    border-radius: var(--border-radius);
    background: rgba(237, 106, 94, 0.3);
  }

  article pre {
    max-width: 840px !important;
    margin: 15px auto !important;
    font-size: 14px !important;
    box-sizing: border-box;
    border-radius: var(--border-radius) !important;
    tab-size: 2 !important;
    padding: 0 !important;
  }

  article pre code {
    display: block;
    margin: 20px 30px !important;
    overflow: auto !important;
    font-size: inherit !important;
  }

  article hr {
    max-width: 840px;
    margin: 40px auto;
    border-color: var(--tertiary-color);
  }

  article blockquote {
    max-width: 840px;
    padding: 0 30px;
    margin: 15px auto;
    position: relative;
    font-style: italic;
    font-size: 14px;
    color: var(--secondary-color);
  }

  .table-container {
    max-width: 840px;
    padding: 0 30px;
    margin: 15px auto;
  }

  .table-container table {
    border-collapse: collapse;
  }

  .table-container td {
    font-size: 14px;
    color: var(--normal-color);
    border: 1px solid var(--tertiary-color);
    padding: 10px;
  }

  article blockquote::before {
    content: '';
    position: absolute;
    top: 0;
    left: 30px;
    width: 3px;
    height: 100%;
    background-color: var(--primary-color);
  }

  article blockquote p {
    font-size: 14px;
    color: inherit;
    max-width: unset;
    padding: 0;
    margin: 0 0 0 30px;
  }

  article ul,
  article ol {
    max-width: 840px;
    padding: 0 30px;
    margin: 15px auto;
    color: var(--normal-color);
    line-height: 1.5;
  }
  
  article ul li, article ol li {
    display: block;
    margin: 5px 0;
    position: relative;
  }

  article ul li::before, article ol li::before {
    content: '';
    display: block;
    position: absolute;
    top: calc(50% - 2px);
    left: -15px;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background-color: var(--normal-color);
  }

  article figcaption {
    font-size: 12px;
    color: var(--secondary-color);
    text-align: center;
    margin-top: 5px;
  }

  .figure-img {
    max-width: 840px;
    padding: 0 30px;
    margin: 15px auto;
  }

  .figure-img img {
    display: block;
    max-width: 100%;
    margin: 0 auto;
    border-radius: var(--border-radius);
  }

  .figure-iframe {
    width: 100%;
    margin: 15px 0;
  }

  .figure-iframe iframe {
    display: block;
    width: 100%;
    max-width: 840px;
    margin: 0 auto;
    height: 640px;
    border: none;
    border-radius: var(--border-radius);
  }
</style>

<section>
  <h2 id="styledcomponents">styled-components</h2>
<p>在 react 应用中样式使用 css 文件存在几个痛点:</p>
<ol>
<li>需要额外的样式文件, 比如一个 A 组件往往附带了一个 A.(css|less|scss|styl) 的样式文件, 而且样式与结构和逻辑分离不符合组件化的思想</li>
<li>为了防止样式互相污染, 类似于 BEM 规范命名的 classname 非常冗长, 而且增加打包体积</li>
<li>JavaScript 只能通过 classname 或者 style 属性修改样式</li>
<li>样式难以复用</li>
<li>当一个组件被删除时, 它的样式文件不一定同时删除从而成为遗留垃圾文件</li>
</ol>
<p>css-in-js 可以解决上面这些问题, 在众多的 css-in-js 的方案中这里推荐的是 <a href="https://styled-components.com">styled-components</a>.</p>
<blockquote>
  <p>之所以采用 styled-components 是因为它是 css-in-js 里面用的最多的. 我个人的理解是选用一门技术不是要看这门技术有多高深, 而是看它是不是用的最广泛. 用的最广泛也就是说基本上你遇到过的坑, 别人已经帮你踩过了.</p>
</blockquote>
<p>styled-components 有三个常用的 API, <code>styled</code>, <code>css</code> 和 <code>keyframes</code>.</p>
<p>首先是 styled 用于创建标签</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;

// &#x5F15;&#x5165;styled-components
import styled from &apos;styled-components&apos;;

// &#x6BD4;&#x5982;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A; div
const Container = styled.div`
  // &#x6837;&#x5F0F;&#x5199;&#x5728;&#x8FD9;&#x91CC;, &#x652F;&#x6301; scss &#x8BED;&#x6CD5;
  font-size: 16px;
  color: red;
`;
// &#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x628A; Container &#x5F53;&#x505A;&#x666E;&#x901A; div &#x53BB;&#x4F7F;&#x7528;
const Component = () =&gt; (
  &lt;Container
    onClick={() =&gt; alert(&apos;hello styled!&apos;)} // &#x6DFB;&#x52A0;&#x4E8B;&#x4EF6;
    data-balloon=&quot;styled-components&quot; // &#x6DFB;&#x52A0; dom &#x5C5E;&#x6027;
  &gt;
    hello styled!
  &lt;/Container&gt;
);
</code></pre>
<p>跟上面一样, 当我们需要 span/button/a/… 这些标签的时候, 也是通过 styled.[tagName]`样式` 这种写法.</p>
<pre><code class="jsx language-jsx">// span
styled.span`
  // &#x6837;&#x5F0F;
`;

// button
styled.button`
  // &#x6837;&#x5F0F;
`;

// a
styled.a`
  // &#x6837;&#x5F0F;
`;

// ...
</code></pre>
<p>和 css 文件相比, styled-components 可以让样式写在组件里面, 不需要我们额外创建一个样式文件以及写非常冗长的 className, 所以不需要担心 className 相同导致样式污染的问题. 不同于 css 文件方式只能通过修改 className 和 style 属性的方式修改样式, styled-components 可以直接通过 props 修改样式.</p>
<p>比如下面这个例子, 我们可以传递 props 给 styled-components, 然后可以在样式里面插入一个 props 处理方法然后返回需要的样式</p>

      <figure class="figure-iframe">
        <iframe src="https://codesandbox.io/embed/hopeful-meitner-5lbw5?fontsize=14&hidenavigation=1&theme=dark" title="styled_components_with_props" loading="lazy"></iframe>
        <figcaption>styled_components_with_props</figcaption>
      </figure>
    
<p>题外话, 上面 styled.[tagName]`样式` 写法其实是模板字符串一种叫做 <code>tagged template</code> 的用法, 比如</p>
<pre><code class="js language-js">const name = &apos;xxx&apos;;

console.log`hello ${name}`;
// &#x76F8;&#x5F53;&#x4E8E;
console.log([&apos;hello&apos;, &apos;&apos;], name);
</code></pre>
<p>所以 styled-components 能够提取里面变量或者方法执行, 对模板字符串这种用法感兴趣的可以了解下.</p>
<p>然后是 <code>css</code> 和 <code>keyframes</code> , css 用于创建样式片段, keyframes 用于创建动画, 比如</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;
import Types from &apos;prop-types&apos;;
import styled, { css, keyframes } from &apos;styled-components&apos;;

// &#x900F;&#x660E;&#x5EA6;&#x4ECE;0&#x5230;1&#x7684;&#x52A8;&#x753B;
const fadeIn = keyframes`
  0% {
    opacity: 0;
  } 100% {
    opacity: 1;
  }
`;

// &#x6587;&#x672C;&#x6EA2;&#x51FA;&#x5C55;&#x793A;...
const ellipsis = css`
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  color: ${({ color }) =&gt; color};
`;

// &#x8FD9;&#x65F6;&#x53EF;&#x4EE5;&#x5C06; fadeIn &#x548C; ellipsis &#x50CF;&#x666E;&#x901A;&#x53D8;&#x91CF;&#x4E00;&#x6837;&#x63D2;&#x5165;&#x5230;&#x6837;&#x5F0F;&#x4E2D;
const Container = styled.div`
  color: red;
  font-size: 16px;
  animation: ${fadeIn} 1s linear;
  ${ellipsis}
`;
</code></pre>
<p>通过 css 和 keyframes 可以提取常用的样式片段和动画进行复用.</p>
<p>下面是使用 styled-components 实现一个进度条组件的例子(提示: 这个组件虽然能够正常工作, 但存在隐藏的性能问题, 查看完整的 styled-components <a href="https://styled-components.com">官方文档</a>应该能找出问题所在)</p>

      <figure class="figure-iframe">
        <iframe src="https://codesandbox.io/embed/infinite-class-name-yd3w1?fontsize=14&hidenavigation=1&theme=dark" title="infinite-class-name" loading="lazy"></iframe>
        <figcaption>infinite-class-name</figcaption>
      </figure>
    
<p>styled-components 还可用来修改已有组件的样式, 比如需要在一些公用组件的基础上修改样式或者第三方组件库, 通过 styled-components 我们不需要插入 className 或者 style 属性的方式可以对样式进行修改, 以 antd 作为例子</p>

      <figure class="figure-iframe">
        <iframe src="https://codesandbox.io/embed/silly-davinci-9qke3?fontsize=14&hidenavigation=1&theme=dark" title="styled-other-component" loading="lazy"></iframe>
        <figcaption>styled-other-component</figcaption>
      </figure>
    
<p>因为 styled-components 是通过模板字符串创建样式, 所以编辑器会把样式当做普通字符串处理. 这时需要安装额外的插件, 比如在 vscode 中 <a href="https://github.com/styled-components/vscode-styled-components">vscode-styled-components</a> 插件可以高亮 styled-components 中的样式以及支持输入提示, 配合 <a href="https://prettier.io/">prettier</a> 可以做到自动格式化.</p>

      <figure class="figure-img">
        <a href="/article/b49bc3737b4b461b8f80a502e5a887f5.gif" target="_blank">
          <img src="/article/b49bc3737b4b461b8f80a502e5a887f5.gif" alt title loading="lazy">
        </a>
        
      </figure>
    
<p>其他编辑器的高亮和格式化可以参考<a href="https://styled-components.com/docs/tooling#syntax-highlighting">官方文档</a>.</p>
<h2 id="react">react 即将废弃以及新的生命周期方法</h2>
<p>在大于 react@16.4 的版本中新增了 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 两个新的生命周期方法, 同时给出了 <code>componentWillMount</code>, <code>componentWillReceiveProps</code> 和 <code>componentWillUpdate</code> 这三个生命周期方法将被弃用的警告, 以及在 react@17 的版本中这三个生命周期方法将会替换成 <code>UNSAFE_componentWillMount</code>, <code>UNSAFE_componentWillReceiveProps</code> 和 <code>UNSAFE_componentWillUpdate</code>, 在更往后的版本这些生命周期方法还会被删除.</p>
<p>react 的目的是让我们不要再用这三个生命周期方法, 如果需要用到这三个生命周期方法的话, 应该用新的生命周期方法替代, 同时旧代码也应当及时替换掉这三个即将废弃的生命周期方法, 这样做的目的是为了实现 react 的<a href="http://react.html.cn/blog/2018/03/27/update-on-async-rendering.html">异步渲染</a>, 至于如何用新的生命周期方法替换这三个即将废弃的生命周期方法, 可以参看<a href="http://react.html.cn/blog/2018/03/27/update-on-async-rendering.html#examples">官方例子</a>.</p>
<p>除了用新的生命周期方法替换这些即将被废弃的方法, 你还可以尝试用 react hook.</p>
<h2 id="reacthook">react hook</h2>
<p>在 react@16.8 的版本中推出了 hook, hook 能够使 <code>function component</code> 拥有状态和模拟生命周期方法的特性.</p>
<p>在 hook 之前, 先看一下目前 class component 存在的一些问题:</p>
<blockquote>
  <p>相关逻辑分散在不同的生命周期方法, 比如在 componentDidMount 里面设置订阅, 然后在 componentWillUnmount 取消订阅, 当产生修改的时候很容易只修改了一处而忘了另一处的修改, 从而容易产生 bug</p>
  <p>class 中的 this 难以理解, 这也容易导致 bug. 大部分人应该都遇到过忘记将类方法绑定 this 产生的 bug.</p>
  <p>难以复用状态和逻辑. 许多组件包含相同的状态的逻辑, 但是却拥有多份代码, 当发生修改时容易产生遗漏. 高阶组件能在一定程度上解决这个问题, 但是会导致 render tree 嵌套过深, 例如下图</p>
</blockquote>

      <figure class="figure-img">
        <a href="/article/afa5e1f94624dc520320e74c786331cc.png" target="_blank">
          <img src="/article/afa5e1f94624dc520320e74c786331cc.png" alt title loading="lazy">
        </a>
        
      </figure>
    
<p>基于上面这些问题 react 推出了 hook.</p>
<p>hook 包含了 <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, <code>useReducer</code>, <code>useCallback</code>, <code>useMemo</code>, <code>useRef</code>, <code>useImperativeHandle</code>, <code>useLayoutEffect</code>, <code>useDebugValue</code> 这十个基础 hook 以及由这些基础 hook 组成的自定义 hook. 这里需要注意的是, hook 只能在 function component 里面使用, 不能在 class component 或者普通函数中使用. 下面只介绍几个常用的 hook, 完整 api 可以参考<a href="https://reactjs.org/docs/hooks-intro.html">官方文档</a>.</p>
<h3 id="usestate">useState</h3>
<p><code>useState</code> 可以让 function component 拥有状态的特性, useState 接受一个初始值的参数(如果初始值需要计算的话, 可以传入一个初始化方法), 然后返会状态以及变更状态的一个数组, 然后就可以使用这个状态以及更新这个状态.</p>

      <figure class="figure-iframe">
        <iframe src="https://codesandbox.io/embed/dry-shape-ymg5s?fontsize=14&hidenavigation=1&theme=dark" title="use_state" loading="lazy"></iframe>
        <figcaption>use_state</figcaption>
      </figure>
    
<p>可以思考下<a href="https://reactjs.org/docs/hooks-state.html#tip-what-do-square-brackets-mean">为什么 useState 返回一个数组</a>?</p>
<h3 id="useeffect">useEffect</h3>
<p><code>useEffect</code> 用于引入含有副作用的操作, 副作用比较难理解, 如果换成可以模拟生命周期方法就容易理解多了.</p>
<p>useEffect 有两个参数, 第一个参数是一个方法, 第二个可选参数是一个可选的依赖项数组, 当数组里面的依赖项发生变化的时候, 第一个方法参数就会被执行. 当不指定依赖项数组时, 则表示每次更新都需要执行第一个方法参数.</p>
<pre><code class="jsx language-jsx">import React, { useEffect } from &apos;react&apos;;

const Component = ({ count }) =&gt; {
  // &#x6A21;&#x62DF; componentDidMount
  useEffect(() =&gt; {
    console.log(&apos;component did mount&apos;);
  }, []); // &#x4E0D;&#x6307;&#x5B9A;&#x4F9D;&#x8D56;&#x9879;

  // &#x6A21;&#x62DF; componentWillReceiveProps
  useEffect(() =&gt; {
    console.log(&apos;component will receive props&apos;);
  }, [count]); // &#x4F9D;&#x8D56; count props

  // &#x6A21;&#x62DF; componentDidUpdate
  useEffect(() =&gt; {
    console.log(&apos;component did update&apos;);
  }); // &#x6CA1;&#x6709;&#x4F9D;&#x8D56;&#x9879;

  return &lt;div&gt;...&lt;/div&gt;;
};
</code></pre>
<p><code>useEffect</code> 可以模拟除 <code>componentDidCatch</code>, <code>getSnapshotBeforeUpdate</code> 和 <code>getDerivedStateFromError</code> 以外的所有 class component 生命周期方法.</p>
<p>与生命周期方法不同的是, <code>useEffect</code> 可以更方便地检查 props 的变更以及可以将相关逻辑写在一起. 以聊天室作为例子, 当用户进入不同的聊天室的时候, 需要监听不同的聊天服务器, 当退出聊天室的时候需要取消监听聊天服务器, 用 class component 需要这样写</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;
import Types from &apos;prop-types&apos;;

import chatServer from &apos;path/chat_server&apos;; // &#x8868;&#x793A;&#x804A;&#x5929;&#x670D;&#x52A1;

// &#x804A;&#x5929;&#x5BA4;&#x7EC4;&#x4EF6;
class ChatRoom extends React.PureComponent {
  static propTypes = {
    roomId: Types.number.isRequired, // &#x804A;&#x5929;&#x5BA4;ID
    // other props
  };

  componendDidMount() {
    const { roomId } = this.props;
    chatServer.listen(roomId); // &#x76D1;&#x542C;&#x6307;&#x5B9A;&#x623F;&#x95F4;&#x7684;&#x804A;&#x5929;&#x670D;&#x52A1;
  }

  componendDidUpdate(prevProps) {
    const { prevRoomId } = prevProps;
    const { roomId } = this.props;
    // &#x5F53;&#x5207;&#x6362;&#x623F;&#x95F4;&#x65F6;&#x9700;&#x8981;&#x53D6;&#x6D88;&#x76D1;&#x542C;&#x65E7;&#x623F;&#x95F4;&#x7684;&#x804A;&#x5929;&#x670D;&#x52A1;, &#x76D1;&#x542C;&#x65B0;&#x623F;&#x95F4;&#x7684;&#x804A;&#x5929;&#x670D;&#x52A1;
    if (prevRoomId !== roomId) {
      chatServer.unlisten(prevRoomId);
      chatServer.listen(roomId);
    }
  }

  componentWillUnmount() {
    const { roomId } = this.props;
    chatServer.unlisten(roomId); // &#x53D6;&#x6D88;&#x76D1;&#x542C;&#x6307;&#x5B9A;&#x623F;&#x95F4;&#x7684;&#x804A;&#x5929;&#x670D;&#x52A1;
  }

  render() {
    return &lt;div&gt;...&lt;/div&gt;;
  }
}
</code></pre>
<p>在 class 组件中, 我们需要在 <code>componentDidMount</code> 监听聊天服务, <code>componentWillUnmount</code> 取消监听聊天服务, 同时还需要在 <code>componentDidUpdate</code> 检查聊天室 ID 的变化重新设置聊天服务的监听. 通过 <code>useEffect</code>, 我们可以省略很多逻辑</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;
import Types from &apos;prop-types&apos;;

import chatServer from &apos;path/chat_server&apos;; // &#x8868;&#x793A;&#x804A;&#x5929;&#x670D;&#x52A1;

// &#x804A;&#x5929;&#x5BA4;&#x7EC4;&#x4EF6;
const ChatRoom = ({ roomId }) =&gt; {
  useEffect(() =&gt; {
    chatServer.listen(roomId);
    return () =&gt; chatServer.unlisten(roomId);
  }, [roomId]); // &#x5F53; roomId &#x53D1;&#x751F;&#x53D8;&#x66F4;&#x7684;&#x65F6;&#x5019;&#x81EA;&#x52A8;&#x6267;&#x884C;&#x91CC;&#x9762;&#x7684;&#x65B9;&#x6CD5;

  return &lt;div&gt;...&lt;/div&gt;;
};
</code></pre>
<p>需要注意的是, useEffect 里面的方法返回了一个取消监听的方法, 表示 roomId 发生变更之后先执行这个取消监听的方法, 然后再执行新 roomId 的聊天服务监听, 这样做的好处的是能够把订阅和取消订阅两个相关的逻辑写在一起, 不必分散在不同生命周期方法. 同时, 当 ChatRoom 组件被卸载的时候, 取消订阅的方法同样也会被执行, 我们不需要用额外的代码去干预.</p>
<h3 id="usememousecallback">useMemo 和 useCallback</h3>
<p><code>useMemo</code> 和 <code>useCallback</code> 用于缓存, useMemo 用于缓存变量, useCallback 用于缓存方法, 这两个方法和 useEffect 一样需要指明依赖项, 当依赖项发生变更的时候, 它们的缓存才会更新</p>
<pre><code class="jsx language-jsx">import React, { useMemo, useCallback } from &apos;react&apos;;

const Component = ({ a, b, c }) =&gt; {
  // a &#x53D1;&#x751F;&#x53D8;&#x66F4;&#x7684;&#x65F6;&#x5019;&#x624D;&#x4F1A;&#x91CD;&#x65B0;&#x8BA1;&#x7B97; double &#x7684;&#x503C;
  const double = useMemo(() =&gt; a * 2, [a]);

  // b &#x53D1;&#x751F;&#x53D8;&#x66F4;&#x7684;&#x65F6;&#x5019;&#x624D;&#x4F1A;&#x751F;&#x6210;&#x65B0;&#x7684; logB &#x65B9;&#x6CD5;
  const logB = useCallback(() =&gt; console.log(b), [b]);

  return &lt;div&gt;...&lt;/div&gt;;
};
</code></pre>
<p>useMemo 和 useCallback 对于一些高频率更新的组件有很好的性能优化效果. 以上面这个组件为例, double 和 logB 都不依赖 c, 所以 c 无论如何变化, double 和 logB 都只会使用缓存.</p>
<h3 id="hook">自定义 hook</h3>
<p>通过 useState, useEffect 这些基础 hook 的组合可以实现自定义 hook, 这能够抽离一些通用逻辑进行复用. 这里有一个约定, 自定义 hook 需要用 <code>use</code> 前缀命名, 这样 eslint 的 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">hook 插件</a>才会去检查里面的语法和依赖.</p>
<p>我们先来看一个例子</p>
<pre><code class="jsx language-jsx">import React, { useState, useEffect, useEffect } from &apos;react&apos;;

import logger from &apos;path/logger&apos;; // &#x65E5;&#x5FD7;&#x8BB0;&#x5F55;

const Popup = () =&gt; {
  // &#x63A7;&#x5236; popup &#x662F;&#x5426;&#x6253;&#x5F00;
  const [open, setOpen] = useState(false);
  const onOpen = useCallback(() =&gt; setOpen(true), []);
  const onClose = useCallback(() =&gt; setOpen(false), []);

  useEffect(() =&gt; {
    logger.log(`popup ${open ? &apos;open&apos; : &apos;close&apos;}`); // &#x8BB0;&#x5F55; popup &#x6253;&#x5F00;/&#x5173;&#x95ED;&#x65E5;&#x5FD7;
  }, [open]);

  // do popup thing

  return &lt;div&gt;popup&lt;/div&gt;;
};

const Dialog = () =&gt; {
  // &#x63A7;&#x5236; dialog &#x662F;&#x5426;&#x6253;&#x5F00;
  const [open, setOpen] = useState(false);
  const onOpen = useCallback(() =&gt; setOpen(true), []);
  const onClose = useCallback(() =&gt; setOpen(false), []);

  useEffect(() =&gt; {
    logger.log(`dialog ${open ? &apos;open&apos; : &apos;close&apos;}`); // &#x8BB0;&#x5F55; dialog &#x6253;&#x5F00;/&#x5173;&#x95ED;&#x65E5;&#x5FD7;
  }, [open]);

  // do dialog thing

  return &lt;div&gt;dialog&lt;/div&gt;;
};
</code></pre>
<p>上面 popup 和 dialog 组件都有一部分相似的逻辑, 包含了 open 的状态, onOpen 和 onClose 的方法以及记录打开和关闭的日志, 这种情况下就可以把这部分逻辑抽离成一个自定义 hook 进行复用, 假设我们把这个自定义 hook 叫做 <code>useSwitch</code>.</p>
<pre><code class="jsx language-jsx">// use_switch.js
import { useState, useCallback, useEffect } from &apos;react&apos;;

import logger from &apos;path/logger&apos;; // &#x65E5;&#x5FD7;&#x8BB0;&#x5F55;

/**
 * type &#x8868;&#x793A; popup &#x8FD8;&#x662F; dialog
 * &#x56E0;&#x4E3A;&#x9700;&#x8981;&#x533A;&#x522B;&#x65E5;&#x5FD7;&#x8BB0;&#x5F55;
 */
export default (type) =&gt; {
  const [open, setOpen] = useState(false);
  const onOpen = useCallback(() =&gt; setOpen(true), []);
  const onClose = useCallback(() =&gt; setOpen(false), []);

  useEffect(() =&gt; {
    logger.log(`${type} ${open ? &apos;open&apos; : &apos;close&apos;}`); // &#x8BB0;&#x5F55;&#x6253;&#x5F00;/&#x5173;&#x95ED;&#x65E5;&#x5FD7;
  }, [open, type]); // &#x8FD9;&#x91CC;&#x9700;&#x8981;&#x5C06; type &#x6DFB;&#x52A0;&#x5230;&#x4F9D;&#x8D56;&#x9879;

  return {
    open,
    onOpen,
    onClose,
  };
};
</code></pre>
<p>这样就完成了一个自定义 hook, 可以像其他基础 hook 一样在组件里面使用</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;

import useSwitch from &apos;path/use_switch&apos;;

const Popup = () =&gt; {
  const { open, onOpen, onClose } = useSwitch(&apos;popup&apos;); // type = popup
  // do popup thing
  return &lt;div&gt;popup&lt;/div&gt;;
};

const Dialog = () =&gt; {
  const { open, onOpen, onClose } = useSwitch(&apos;dialog&apos;); // type = dialog
  // do dialog thing
  return &lt;div&gt;dialog&lt;/div&gt;;
};
</code></pre>
<p>通过自定义 hook, 达到了公共逻辑复用的效果. 如果一个很复杂的 function component 里面包含很多 hook 的话, 同样也可以将相关的部分提取成自定义 hook</p>
<pre><code class="jsx language-jsx">const Component = () =&gt; {
  useA(); // a &#x76F8;&#x5173; hook
  useB(&apos;xxx&apos;); // b &#x76F8;&#x5173; hook
  useC(); // c &#x76F8;&#x5173; hook

  return &lt;div&gt;...&lt;/div&gt;;
};
</code></pre>
<p>目前很多 react 第三方库推出了自定义 hook 的 api, 例如 <code>react-redux</code> 新增了 <code>useSelector</code> 和 <code>useDispatch</code>, 组件不需要通过 <code>connect</code> 也能够使用 redux state</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;
import { useSelector, useDispatch } from &apos;react-redux&apos;;

const Component = () =&gt; {
  const user = useSelector((state) =&gt; state.user); // &#x8FD4;&#x56DE; redux &#x91CC;&#x9762;&#x7684; user
  const dispatch = useDispatch();

  return &lt;div&gt;...&lt;/div&gt;;
};

// ...
</code></pre>
<p><code>react-router-dom</code> 也提供了 <code>useLocation</code>, <code>useHistory</code> 等多个 api</p>
<pre><code class="jsx language-jsx">import React from &apos;react&apos;;
import { useLocation, useHistory } from &apos;react-router-dom&apos;;

const Component = () =&gt; {
  const history = useHistory();
  const location = useLocation();

  // do something

  return &lt;div&gt;...&lt;/div&gt;;
};

// ...
</code></pre>
<p>除了上面这些以外, react 还有其他 6 个基础 hook, 比如 <code>useReducer</code> 可以用来实现 redux, 完整 hook 教程建议看<a href="https://reactjs.org/docs/hooks-intro.html">官方文档</a>, 文档写的非常不错.</p>
<h4 id>参考</h4>
<ul>
<li><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/09/react-hooks.html">React Hooks 入门教程</a></li>
</ul>
</section>

    <section>
  <h2>更新记录</h2>
  <div class="table-container">
    <table>
      
        <tbody><tr>
          <td>2020-03-31</td>
          <td>移除部分 styled-components 高级 api 的内容</td>
        </tr>
       
    </tbody></table>
  </div>
</section>

  </article>
  
<style>
  .article-action {
    max-width: 840px;
    margin: 40px auto;
    padding: 0 30px;
    font-family: common_font;
    color: var(--normal-color);
  }
  .article-action > a {
    color: inherit;
    text-decoration-color: var(--primary-color);
  }
</style>

<p class="article-action">
  本文使用
  <a href="https://github.com/mebtte/article/issues">Issues</a>
  讨论或直接在
  <a href="https://github.com/mebtte/article/edit/master/articles/styled_components_and_update_react_to_hooks/index.md">Github</a>
  编辑.
</p>

  <style>
.page-footer{
  font-size: 12px;
  max-width: 840px;
  margin: 40px auto;
  padding: 0 30px;
  font-family: common_font;
  color: var(--secondary-color);
}

.page-footer > a {
  text-decoration: none;
  color: inherit;
}

.page-footer > a:hover {
  color: var(--primary-color);
}
</style>

<footer class="page-footer">
  <a href="https://github.com/mebtte/article/blob/master/LICENSE">©</a> 2020
  <a href="https://mebtte.com">MEBTTE</a>
</footer>


  <script src="/article/39c97c2884c3a2b5e64c8f085b843d4e.js"></script>



</body></html>